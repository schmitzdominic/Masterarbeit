% !TEX root = Old.tex


\begin{comment}
	Inhalt...\section{Automatisiertes Testen}
	Viele Unternehmen versuchen mit möglichst geringen Mitteln ihre Software zwar gründlich, aber auch so schnell und umfangreich wie möglich zu testen. Viele Tests können nicht manuell durchgeführt werden, da sie zu viel Zeit in Anspruch nehmen oder zu umfangreich wären. Ein Beispiel ist ein sogenannter Massentest mit mehreren Tausend virtuellen Benutzern. In diesen Bereichen kann sich die Automatisierung von Tests durchaus lohnen. Bei der Testautomatisierung ist allerdings auch zu beachten das die Testarbeit genauso zeitaufwendig wie die Arbeit an der Entwicklung einer Anwendung sein kann. So wird beispielsweise Software im laufe ihres Lebenszyklus mehrfach verändert und angepasst. Alle dieser Änderungen können Tests beeinflussen und müssen entsprechend angepasst werden \autocite{testautomatisierung}.
	
	In der Praxis reicht Selenium häufig nicht um Tests zu Automatisieren. 
	
	Wie in Kapitel \ref{def:Testarten} beschrieben gibt es verschiedene Testarten, die verschieden Bereiche einer Software testen. Als Beispiel lässt sich hier sehr gut ein Akzeptanztest und ein Unit-Test nehmen. Während der Unit-Test nur testet ob einzelne Funktionen das richtige machen, wird beim Akzeptanztest getestet ob die gesamte Software das richtige macht. Das hat zur Folge, dass Entwickler ihre Tests nur für ihren speziellen Fall definieren und Stakeholder im Normalfall nichts davon mitbekommen. 
	
	Das liegt daran, dass diese häufig nur schwer nachvollziehbar und ohne Programmierkenntnisse schwer zu verstehen sind. Aus diesem Grund wurden Techniken wie etwa das Behavior Driven Development (\acs{BDD}) entwickelt. 
	
	\newline\newline
	Beim \acs{BDD} werden schon während der Analyse der Anforderungen die Aufgaben, Ziele und Ergebnisse der Software in textueller Form festgehalten. Im späteren Verlauf können diese dann automatisiert werden und somit die Software auf ihre 
\end{comment}
\chapter{Begriffsdefinitionen}
Teil dieser Arbeit, ist die Verwendung und das Zusammenspiel unterschiedlicher Software. Um ein Verständnis für die in dieser Arbeit verwendeten Begriffe zu erlangen, werden die Wichtigsten im folgenden Kapitel erläutert. 

\section{Python} \label{ssec:python}
Python ist eine laut \autocite{python} einfach zu lernende, mächtige, Objekt orientierte Programmiersprache, mit der sich simpel, aber sehr effektiv programmieren lässt. Der Python-Interpreter und alle Standardbibliotheken sind für alle großen Plattformen, wie etwa Windows, Mac OS und Linux frei verfügbar \autocite{python}. 

\section{Selenium} \label{ssec:selenium}
Selenium ist ein Funktions- und Akzeptanztest Tool für Web Applikationen und stellt alle Hilfsmittel zum Testen von Webapplikationen zur Verfügung. Mithilfe von Selenium, ist es möglich clientseitige Tests auf Basis von Javascript durchzuführen. Eine weitere Eigenschaft ist die Unterstützung von mehreren Plattformen und Browsern \autocite{selenium1}. 

\section{Pytest} \label{ssec:pytest}
Mithilfe von Pytest ist es möglich Testfälle zu definieren und auszuwerten. Pytest ermöglicht es, Tests eine Struktur zu verleihen und diese für den Anwender lesbar zu gestalten. Die Auswertung der Tests und eventuelle Fehler werden mithilfe von Pytest wie in Abbildung \ref{img:pytest_ergebnis} übersichtlich in der Konsole nach Abschluss des Tests dargestellt. Grundvoraussetzung zur Benutzung von Pytest ist \ref{ssec:python} Python mit der Version 2.7, 3.4, 3.5, 3.6, Jython oder PyPy-2.3 (Stand 28.11.2017) \autocite{pytest}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{08_Bilder/pytest_ergebnis.png}
	\setlength{\abovecaptionskip}{-1em}
	\caption{Testauswertung Pytest}
	\label{img:pytest_ergebnis}
\end{figure} 

\section{Cypress} \label{ssec:cypress}
Auf \autocite{cypress} wird Cypress als die nächste Generation im Front-End Testing beschrieben. Dabei verspricht Cypress vor allem, dass erstellen, schreiben, ausführen und debuggen von Tests zu vereinfachen. Cypress wird oft mit \ref{ssec:selenium} Selenium verglichen da es ebenfalls ein Funktions- und Akzeptanztest Tool für Web Applikationen ist und zusätzliche Hilfsmittel zum Testen von Webapplikationen zur Verfügung stellt \autocite{cypress}.

\section{Git / Github}

\subsection{Git} \label{ssec:git}
Git ist ein System zur verteilten Versionsverwaltung mehrerer Dateien. Es wurde unter den Aspekten Geschwindigkeit, einfaches Design, guter Unterstützung von nicht-linearer Entwicklung, vollständiger Verteilung und der Fähigkeit große Projekte effektiv zu verwalten entwickelt. Das Prinzip besteht darin, den Zustand einer oder mehrerer Dateien zu sichern und diese sogenannten \glspl{snapshot}, unter einer Referenz abzuspeichern. Bei diesem Vorgang werden unveränderte Dateien nicht erfasst, es wird lediglich eine Verknüpfung zu der Datei erstellt. Durch diese Vorgehensweise wird die Effizienz und Geschwindigkeit besonders bei großen Projekten enorm gesteigert. Ein weiterer großer Vorteil ist die Möglichkeit einen \gls{branch} zu erstellen. Ein \gls{branch} in Git ist ein simpler Zeiger, der auf einen Codestand verweist. Er ermöglicht es, an mehreren Codeständen zur selben Zeit zu entwickeln und diese später zusammen zu führen \autocite{gitbook}.

\subsection{Github} \label{ssec:github}
Github ist eine im Jahre 2007 in San Francisco gegründete Website, mit der es möglich ist Entwicklungsprojekte anzulegen und zu verwalten. In sogenannten \glspl{repository} werden Daten und Codestände verschiedener Projekte gespeichert und können mithilfe der Versionsverwaltung Git abgerufen und verändert werden \autocite{github}.

\section{Travis} \label{ssec:travis}
Mit Travis ist es möglich Software Tests automatisiert auszuführen. Travis kann mit einem öffentlichen (Kostenfrei) oder einem privaten (Kostenpflichtig) Github \gls{repository} verknüpft werden. Die Website hat dafür zwei unterschiedliche Domains bereit gestellt. travis-ci.org für öffentliche Projekte und travis-ci.com für private Projekte. Jedes Mal wenn eine Änderung des Codes auf dem verknüpften Github-\gls{repository} stattfindet, lässt sich mithilfe von Konfigurationsdateien bestimmen, welche Anweisungen erfolgen. Diese Anweisungen müssen nicht zwingend das Ausführen von Tests enthalten, es können auch Anweisungen zum versenden von Nachrichten oder Erstellen von Berichten sein \autocite{travis}.

%PYRMIDE
Unter dem Begriff Oberflächentests werden häufig Akzeptanztests \ref{def:Akzeptanztest}, End-to-End Tests \ref{def:EndtoEndTest}, Explorative Tests \ref{def:ExplorativerTest} oder Smoke Tests \ref{sssec:smoke} eingeordnet. In der Vergangenheit wurde versucht, diesen Anteil zu automatisieren um mit möglichst geringen Mitteln, Software zwar gründlich, aber auch so schnell und umfangreich wie möglich zu testen \autocite{testautomatisierung}.

\subsection{Hybride Tests}
Hier werden alle Testarten aufgeführt, die im Bezug auf die \ref{def:testpyramide} Testpyramide entweder Integrations- oder als Oberflächentests ausgeführt werden können. 

\subsubsection{Regressionstest} 
Software wird über ihren gesamten Lebenszyklus mehrfach verändert und angepasst. Im Zuge dieser Veränderungen kann es passieren, dass zuvor erfolgreich getestete Komponenten plötzlich nicht mehr funktionieren, da viele Komponenten Abhängigkeiten untereinander aufweisen. Aus diesem Grund ist es notwendig, auch bereits getestete Komponenten regelmäßig erneut zu testen, um eventuelle Fehler sofort zu analysieren. Diese Tests werden Regressionstests genannt \autocite{testarten}.

\subsubsection{Smoke Test} \label{sssec:smoke}
Smoke Testing prüft ob eine Applikation derart beschädigt und fehlerhaft ist, dass es keinen Sinn mehr macht diese weiter zu Prüfen. Früher wurden Geräte nach einer Reparatur, bei der ersten Inbetriebnahme geprüft, ob diese einwandfrei funktionieren oder Rauch (englisch Smoke) aufsteigt. Heutzutage in der Softwareentwicklung werden eher die grundlegenden Funktionen des Systems, beim ersten Testlauf auf Fehler geprüft. Beim Smoke Testing werden Schritte definiert, die vom Tester abgearbeitet werden müssen. Jeder Schritt hat zusätzlich ein Feld mit dem Erwarteten Ergebnis. Entspricht das Verhalten während des Tests nicht diesem, schlägt der Test fehl \autocite{testarten}.

Um einen Tests zu schreiben wird immer eine entsprechende Syntax vorgeschrieben. Cypress nutzt die Syntax von JavaScript \autocite{cypress}. Um bestimmte Aktionen auf einer Website entsprechend auszuführen und Meldungen abzufangen, werden bestimmte Kommandos verwendet. Jedes Kommando hat eine eigene Funktion. Folgend werden die wichtigsten Kommandos erläutert.

\subsection{visit} \label{def:visit}
\lstset{style=cypress, caption={visit}, label={lst:cy_visit}}
\begin{lstlisting}
cy.visit(url, options)
\end{lstlisting} 

Hier kommt die Beschreibung von Visit rein!

\subsection{get}

\subsection{route}

\subsection{wait}

\section{Erste Tests}
Nachdem Cypress korrekt installiert wurde, wird jetzt damit begonnen einen ersten Test zu schreiben. Nachfolgend werden die Tests weiterentwickelt.

\lstset{style=cypress, caption={Erster Test}, label={lst:erster_test}}
\begin{lstlisting}
describe('Erster Test', function() {
it('Prüft nur ob true gleich true ist', function() {
expect(true).to.equal(true)
})
})
\end{lstlisting} 

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{08_Bilder/erster_test_ergebnis.png}
	\setlength{\abovecaptionskip}{-1em}
	\caption{Erster Test Ergebnis}
	\label{img:erster_test_ergebnis}
\end{figure}

Das Keyword \enquote{describe} beschreibt, um was für einen Test es sich handelt. Bei dem Keyword \enquote{it} zu Deutsch \enquote{es}, handelt es sich um Schritte, die abgearbeitet werden müssen. Somit sagt der erste Test (siehe Listing \ref{lst:erster_test}) folgendes aus:

\begin{enumerate}
	\item Es handelt sich um den Test \enquote{Erster Test}.
	\item Dieser Test \enquote{Prüft nur ob true gleich true ist}.
\end{enumerate}

In der dritten Zeile sagt das Keyword \enquote{expect} aus, was der Test erwartet. In diesem Fall wird \enquote{true} durch \enquote{.to.equal()} erwartet. Momentan wird explizit der Wert true angegeben um den ersten Test erfolgreich abzuschließen \autocite{cypress}. 
\newline\newline
In der Abbildung \ref{img:erster_test_ergebnis} wird in Weiß-Grün das Wort \enquote{ASSERT} angezeigt. \glspl{assertion} markieren ein Ereignis im Code, das einen Zustand überprüft. Entspricht der Wert dem vorgegebenen Zustand, wird dieser als erfüllt oder Weiß-Grün dargestellt. Wird der vorgegebene Zustand nicht erfüllt, erscheint Assert in Weiß-Rot und der Test bricht ab \autocite{cypress}. 

\lstset{style=cypress, caption={Zweiter Test}, label={lst:zweiter_test}}
\begin{lstlisting}
describe('Zweiter Test', function() {
it('Besucht die Test-Seite von Cypress.io', 
function(){
cy.visit('https://example.cypress.io')
cy.title().should('include', 'Kitchen Sink')
cy.title().should('eq', 'Cypress')
})
})
\end{lstlisting} 

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{08_Bilder/zweiter_test_ergebnis.png}
	\setlength{\abovecaptionskip}{-1em}
	\caption{Zweiter Test Ergebnis}
	\label{img:zweiter_test_ergebnis}
\end{figure}

Wie in Listing \ref{lst:zweiter_test} zu sehen ist, wird nun der Befehl \enquote{visit} verwendet. Der Befehl ermöglicht es die angegebene Webseite \enquote{https://example.cypress.io} über den, im Cypress Runner angegebenen Browser, zu öffnen.
\newline\newline
Desweiteren wird der Befehl \enquote{title} verwendet. Dieser überprüft mithilfe des ersten Parameters ob der als zweiten Parameter angegebene Titel genau (\enquote{eq}) dem entspricht oder nur enthalten (\enquote{include}) ist.

\lstset{style=cypress, caption={Dritter Test}, label={lst:dritter_test}}
\begin{lstlisting}
describe('First Test', function() {

// Load all the pre Stuff
before(function(){
cy.fixture('kraken/locators.json').as('locator')
cy.fixture('kraken/web.json').as('web')
cy.fixture('kraken/settings.json').as('setting')
})

it('to get the Iframe!', function(){

cy.visit(this.web.krakenUrl)

cy.get('iframe', { timeout: this.setting.delay })
.should('have.class', this.locator.playerIframe)
.should(($iframe) => {
expect($iframe.contents().find(this.locator.playButton)).to.exist

}).then(($iframe) => {
$iframe.contents().find(this.locator.playButton).click();

})
})
})
\end{lstlisting} 


Zur Installation von npm, wird im ersten Schritt Homebrew installiert. Homebrew ist ein \gls{packagemanager} der speziell für Mac OS entwickelt wurde \autocite{brew}. Um die Homebrew Installation zu starten, wird der Befehl aus Listing \ref{lst:install_brew} in der \gls{bash} ausgeführt.
\lstset{style=bash, caption={Homebrew Installation}, label={lst:install_brew}}
\begin{lstlisting}
$ /usr/bin/ruby -e \
"$(curl -fsSL https://raw.githubusercontent.com\
/Homebrew/install/master/install)"
\end{lstlisting} 

Nachdem Homebrew installiert wurde, muss nun npm installiert werden. Bei dem Befehl aus Listing \ref{lst:install_node} ist anzumerken, dass über das Paket "node", npm mit installiert wird.

\lstset{style=bash, caption={Node (inklusive npm) Installation}, label={lst:install_node}}
\begin{lstlisting}
$ brew install node
\end{lstlisting} 
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{08_Bilder/npm_installation.png}
	\setlength{\abovecaptionskip}{-1em}
	\caption{Npm Installation}
	\label{img:npm_inst}
\end{figure}

Wie in Abbildung \ref{img:npm_inst} zusehen ist, wurde die Installation erfolgreich Abgeschlossen. Nun kann wie auf \autocite{cypress} beschrieben, die Cypress-Installation gestartet werden (siehe Listing \ref{lst:install_cypress}). \newpage

\lstset{style=bash, caption={Cypress Installation}, label={lst:install_cypress}}
\begin{lstlisting}
$ npm install cypress
\end{lstlisting} 

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{08_Bilder/cypress_installation.png}
	\setlength{\abovecaptionskip}{-1em}
	\caption{Cypress Installation}
	\label{img:cypress_inst}
\end{figure}

Mithilfe des \glspl{packagemanager} npm wird Cypress erst heruntergeladen, entpackt und anschließend installiert. In der Abbildung \ref{img:cypress_inst} ist ersichtlich, dass die Installation erfolgreich abgeschlossen wurde. Nachdem alle Schritte erfolgreich beendet wurden, muss die Umgebung noch konfiguriert werden.


\newpage
Abbildung \ref{img:selenium_umgebung} zeigt sehr gut, dass Selenium alleine nicht ausreicht. Selenium ist immer auf weitere Frameworks und Programmiersprachen angewiesen, um überhaupt verwertbare Tests erstellen zu können. Das macht es für QA-Abteilungen schwer die richtige Frameworkkombination für die jeweiligen Anforderungen der Tests zu finden. 


\begin{itemize}
	\item \textbf{Installation}\\
	Die Installation eines solchen Testsystems kann sehr komplex werden, da alle Frameworks bestimmte Abhängigkeiten (Versionsnummern, Editionen etc.) voraussetzen. Somit ist für den Anwender schon ein gewisses Vorwissen Voraussetzung, um überhaupt Tests schreiben und lokal ausführen zu können.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.0\textwidth]{08_Bilder/selenium_requirements.png}
		\setlength{\abovecaptionskip}{-1em}
		\caption{Voraussetzungen des Momentanen Systems}
		\label{img:selenium_requirements}
	\end{figure}
	
	Wie in Abbildung \ref{img:selenium_requirements} gezeigt, benötigt das momentane System eine beträchtliche Menge an Software, bevor überhaupt mit der Konfiguration der Umgebung angefangen werden kann.
	
	\item \textbf{Einarbeitung}\\
	Der Aufwand, der Einarbeitung wird durch die häufig auf den ersten Blick unübersichtliche Struktur eines solchen Systems erschwert. Um Tests effektiv zu entwickeln, muss der Anwender sich erst, mit allen Frameworks auseinandersetzen.
	
	\item \textbf{Fehler Ursachen}\\
	Die relativ hohe Komplexität und damit verbundenen Strukturen erschweren das finden von Fehlern und Ursachen. Selenium allein zeigt keine Fehler an. Durch diesen Umstand, muss mithilfe eines Frameworks wie etwa Pytest eine Struktur geschaffen werden, die es ermöglicht, Fehler schnell zu identifizieren. Zusätzlich muss strikt während der Testerstellung auf Nachvollziehbarkeit geachtet werden. Erst dadurch kann über einen Log oder Screenshots nachvollzogen werden, ob ein Fehler wirklich durch die zu Testende Anwendung, oder aufgrund einer fehlerhaften Implementierung verursacht wurde.
	
	\item \textbf{Individualität und Anpassbarkeit}\\
	Durch die hohe Kompatibilität seitens Selenium, kann das System individuell auf die Bedürfnisse der Abteilung angepasst werden. Wenn beispielsweise ein Unternehmen viele Java Entwickler besitzt, kann als Programmiersprache Java in Verbindung mit Selenium verwendet werden. Zusätzlich um die Tests lesbar zu gestalten, muss nur noch eine geeignete \acs{BDD} zum Einsatz kommen (siehe Kapitel \ref{def:BDD}).
	
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{| l |c|}
		\textbf{Kriterium}  & \textbf{Gewichtung} \\ \hline
		Installation           & 1             \\
		Abhängigkeiten und Flexibilität       & 2             \\
		Ausführbarkeit        & 4             \\
		Stabilität        & 5             \\
		Geschwindigkeit       & 3             \\
		Kompatibilität        & 5             \\
		Testaufbau        & 3             \\
	\end{tabular}
	
	\caption{Kriterium Gewichtung von 1 (irrelevant) - 5 (sehr relevant)}
	\label{tbl:kriterium_gewichtung}
	
\end{table}

\item \textbf{Testaufbau}\\
Der Aufbau eines Tests entscheidet ob ein Test notfalls angepasst werden kann. Die Frage hierbei ist, was sind die Unterschiede beim Aufbau eines Tests mithilfe des Frameworks und gibt es eventuelle Vorgaben seitens des Herstellers die eine Vereinheitlichung der Tests ermöglichen. 


	\item \textbf{Stabilität}\\
Die Stabilität eines Tests ist essenziell, um zu gewährleisten das wirklich ein Problem seitens der Anwendung vorliegt. Dabei ist vor allem darauf zu achten, dass das Framework auf Elemente wartet und keine Festen Zeitintervalle angegeben werden müssen. Zusätzlich sollten Tests nur dann fehlschlagen, wenn das Problem durch die zu testende Anwendung verursacht wurde. 

\item \textbf{Geschwindigkeit}\\
Je nach Größe der Tests, kann die Geschwindigkeit eines Tests an Relevanz gewinnen. Große Umgebungen bei denen ein sofortiges Ergebnis benötigt wird um weitere Prozesse nicht zu verzögern profitieren besonders stark von der Geschwindigkeit eines Frameworks. Im Rahmen dieser Arbeit werden allerdings nur kleinere Tests ausgeführt, was dazu führt, dass hier höchstens Sekunden Unterschiede wahrgenommen werden können.





	\item \textbf{Stabilität}\\
X

\item \textbf{Geschwindigkeit}\\
X


 %\section{Problemstellung}
%Vorrangig ist die Stabilität und Zuverlässigkeit des Frameworks zu ermitteln. Da alle Produkte der Glomex beim Kunden verwendet und %eingebunden werden, sind in der Produktentwicklung andere Browser-Plattformen zu behandeln als im Unternehmen selbst. Alle Tests sollen %einfach umzusetzen sein. 

%ANREGUNGEN!
%Ich habe verschiedene Produkte die funktionieren sollen und die Tests sollen zuverlässig sein.
%Produkte die beim Kunden eingesetzt werden und für die Firma.

%stabile UI tests, einfach umzusetzen, Fehler einfach finden, wo besser debuggen, Bedürfnisse der Produktpalette der Glomex muss erfüllt sein, Browserstatistiken

%Eine weitere Anforderung ist die Stabilität der Tests. Diese muss stets gewährleistet werden.

%in die bestehende \gls{travis} Umgebung integrieren lassen. Da es einen erheblichen Aufwand mit sich bringt, alle Objekte einer Website zu identifizieren, wird zusätzlich geprüft ob und wie alle bisherigen Objekte in die neue Umgebung implementiert werden können. 
